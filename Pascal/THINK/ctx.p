unit Ctx;interface	uses		Trace, Die, stack;	const		NESTED_CTXES = 20;	type		Ctx = record				pri, sec, exec: stack;				inp, outp, upexec: PStack;			end;		Ctxes = record				top: 0..NESTED_CTXES;				ctxes: array[1..NESTED_CTXES] of Ctx;			end;		PCtx = ^Ctx;	procedure initCtx;	function newCtx: Ctx;	function newCtxWithExec (exec: Stack): Ctx;	procedure freeCtx (c: Ctx);	procedure startContext (inp, outp: PStack);	procedure startContextAndExec (exec: Stack; inp, outp: PStack);	procedure endContext;	function curContext: PCtx;	procedure traceCurCtx;	function openContextCount: integer;implementation	var		c: Ctxes;{ --- Assertions ---}	procedure ctxFail (s: string);	begin		write('[CTX FAIL] ');		writeln(s);		die;	end;	procedure ThereIsAnActiveContext;	begin		if c.top = 0 then			ctxFail('Run out of contexts.');	end;{ --- Actual guts --- }	function newCtx: Ctx;		var			c: Ctx;	begin		c.pri := newStack;		c.sec := newStack;		c.exec := newStack;		newCtx := c;	end;	function newCtxWithExec (exec: stack): Ctx;		var			c: Ctx;	begin		c.pri := newStack;		c.sec := newStack;		c.exec := cloneStack(exec);		newCtxWithExec := c;	end;	procedure freeCtx (c: Ctx);	begin		freeStack(c.pri);		freeStack(c.sec);		freeStack(c.exec);	end;{ --- make it work ---}	procedure initCtx;	begin		c.top := 0;	end;	procedure startContext (inp, outp: PStack);	begin		c.top := c.top + 1;		c.ctxes[c.top] := newCtx;		c.ctxes[c.top].inp := inp;		c.ctxes[c.top].outp := outp;	{ if this is not the bottom context in the stack, then put a reference in to the parent execution stack. }		if c.top > 1 then			c.ctxes[c.top].upexec := @c.ctxes[c.top - 1].exec;	end;	procedure startContextAndExec (exec: Stack; inp, outp: PStack);	begin		c.top := c.top + 1;		c.ctxes[c.top] := newCtxWithExec(exec);		c.ctxes[c.top].inp := inp;		c.ctxes[c.top].outp := outp;	{ if this is not the bottom context in the stack, then put a reference in to the parent execution stack. }		if c.top > 1 then			c.ctxes[c.top].upexec := @c.ctxes[c.top - 1].exec;	end;	procedure endContext;	begin		ThereIsAnActiveContext;		freeCtx(c.ctxes[c.top]);		c.top := c.top - 1;	end;	function curContext: PCtx;	begin		ThereIsAnActiveContext;		curContext := @c.ctxes[c.top];	end;{ A rudimentary debugging aid }	procedure traceCurCtx;		var			s: str255;			ct: PCtx;	begin		ThereIsAnActiveContext;		if c.top = 1 then			trace('In topmost context:')		else			begin				NumToString(c.top - 1, s);				trace(concat(s, ' context below topmost'));			end;		ct := curContext;		traceStack(ct^.pri, 'PRI');		traceStack(ct^.sec, 'SEC');		traceStack(ct^.exec, 'EXEC');		trace('');	end;	function openContextCount: integer;	begin		openContextCount := c.top;	end;end.