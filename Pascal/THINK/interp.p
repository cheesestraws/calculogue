unit interp;interface	uses		Trace, Die, Tokens, Stack, stdlib, verbcall, Ctx, FloatToStr;	procedure initInterp;	procedure go;	procedure runtok (t: Token; s: string; c: PCtx);	procedure goCtx (c: PCtx);implementation	procedure initInterp;	begin		setStdlibGoCtx(@goCtx);	end;	procedure go;		var			c: PCtx;			e: StackElement;			t: Token;	begin		repeat			c := curContext;{ are there any more tokens to execute on this stack? }			if c^.exec.top > 0 then				begin{ Yes, so run it }					e := pop(c^.exec);					if e.elemType = StringElement then						begin							if tracebool then								trace(concat('Token: ', e.stringValue));							t := strToTok(e.stringValue);							runtok(t, e.stringValue, c);						end;				end			else if openContextCount > 1 then				begin					endContext;				end			else				exit(go);		until false;	end;	procedure goCtx (c: PCtx);		var			e: StackElement;			t: Token;	begin		while c^.exec.top > 0 do			begin				e := pop(c^.exec);				if e.elemType = StringElement then					begin						if tracebool then							trace(concat('Token: ', e.stringValue));						t := strToTok(e.stringValue);						runtok(t, e.stringValue, c);					end;			end;	end;{ This returns a pointer to the stack which the verb is going to operate on.  The TokenStack type is defined}{ in Tokens.p }	function getStackReferenceForName (s: TokenStack; ctx: PCtx; inputStack: boolean): PStack;	begin		case s of			DefaultStack: 				getStackReferenceForName := @ctx^.pri;			SecondaryStack: 				getStackReferenceForName := @ctx^.sec;			ExecStack: 				getStackReferenceForName := @ctx^.exec;			IOStack: 				if inputStack then					getStackReferenceForName := ctx^.inp				else					getStackReferenceForName := ctx^.outp;			ParentExecStack: 				getStackReferenceForName := ctx^.upexec;		end;	end;	procedure runtok (t: Token; s: string; c: PCtx);		var			i: integer;			l: longint;			outstack, instack: PStack;	begin		case t.tokType of			UnknownToken: 				begin					write('[TOKs] Something'' s gone badly wrong . We got a bad token (');					write(s);					writeln(') after they were meant to be filtered out!');					die;				end;			WordToken: 				begin					outstack := getStackReferenceForName(t.stack1, c, false);					pushString(outstack^, t.contents);				end;			NumToken: 				begin					outstack := getStackReferenceForName(t.stack1, c, false);			{ Is this a floating-point or an int? }					if pos('.', t.contents) > 0 then						pushFloat(outstack^, StrToDoubleOrDie(t.contents))					else						begin				{StringToNum is a toolbox routine}				{We should do some error checking here - TODO! }							StringToNum(t.contents, l);							pushInteger(outstack^, l);						end;				end;			VerbToken: 				begin					instack := getStackReferenceForName(t.stack1, c, true);					outstack := getStackReferenceForName(t.stack2, c, false);					verb(t.contents, instack, outstack);				end;		end;		if tracebool then			traceCurCtx;	end;end.