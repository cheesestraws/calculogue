unit stdlib;{}{ Most of this unit is just a straight implementation of the stuff in the 'Standard Library' section of the }{ language spec.  Things worth noting: the fact that \if doesn't actually execute the context itself but just }{ returns to go in interp.pl with a new context on the top of the stack; and the horrible ProcPtr hack to }{ work around the idea that Pascal doesn't do circular references very well. }{}interface	uses		Trace, Die, Stack, verbcall, Ctx;	procedure initStdLib;	procedure setStdlibGoCtx (p: ProcPtr);implementation{ This lets us call goCtx in interp, even though this unit hasn't been actually linked at this point. }{ Look at initInterp in interp.p for details, and the bottom of this unit for the horrible wiring that }{ makes it all possible }	procedure callGoCtx (ctx: PCtx);	forward;{This is the implementation of the standard library }	procedure out_ (inp, outp: PStack);		var			e: StackElement;	begin		e := pop(inp^);		write(elemToString(e));	end;	procedure in_ (inp, outp: PStack);		var			line: string;	begin		readln(line);		pushString(outp^, line);	end;{ \exec creates a new context and grabs some code off its input stack and runs it }	procedure exec (inp, outp: PStack);		var			c: PCtx;			e: StackElement;			count: longint;			i: longint;	begin		e := pop(inp^);		elemMustBe(e, IntElement, '\exec expects a number but didn''t get one.');		count := e.intValue;{ Create a new context }		startContext(inp, outp);		c := curContext;		for i := 1 to count do			begin				e := pop(inp^);				push(c^.exec, e);			end;{ We've set up our context so now we return.  It would be neater to have a goCtx here, but we can't have}{ circular dependencies. }	end;{ \verb creates a new TISBL verb. }	procedure verb_ (inp, outp: PStack);		var			s: Stack;			name: string;			e: StackElement;			count: integer;			i: integer;	begin		e := pop(inp^);		elemMustBe(e, StringElement, '\verb expects a verb name but didn''t get one.');		name := e.stringValue;		e := pop(inp^);		elemMustBe(e, IntElement, '\verb expects a number but didn''t get one.');		count := e.intValue;		s := newStack;		for i := 1 to count do			begin				e := pop(inp^);				push(s, e);			end;		addTISBLVerb(name, s);		freeStack(s);	end;{ \if is a conditional }	procedure if_ (inp, outp: PStack);		var			c: PCtx;			e: StackElement;			count: longint;			i: longint;	begin		startContext(inp, outp);		c := curContext;		e := pop(inp^);		elemMustBe(e, IntElement, '\if expects a number but didn''t get one.');		count := e.intValue;		for i := 1 to count do			begin				e := pop(inp^);				push(c^.exec, e);			end;{ Pop the condition }		e := pop(inp^);		if ((e.elemType = IntElement) and (e.intValue = 0)) or ((e.elemType = FloatElement) and (e.floatValue = 0.0)) then			endContext;	end;{ \while is a loop }	procedure while_ (inp, outp: PStack);		var			c: PCtx;			s: Stack;			e: StackElement;			count, i: longint;			endloop: boolean;	begin		s := newStack;		e := pop(inp^);		elemMustBe(e, IntElement, '\while expects a number but didn''t get one.');		count := e.intValue;		for i := 1 to count do			begin				e := pop(inp^);				push(s, e);			end;{ At this point, s is the execution stack for our loop template }		endloop := false;		repeat			e := pop(inp^);			if ((e.elemType = IntElement) and (e.intValue = 0)) or ((e.elemType = FloatElement) and (e.floatValue = 0.0)) then				endloop := true			else				begin{ startContextAndExec clones the stack automatically }					startContextAndExec(s, inp, outp);					callGoCtx(curContext);					endContext;				end;		until endloop;		freeStack(s);	end;{ \not is ... obvious }	procedure not_ (inp, outp: PStack);		var			e: StackElement;	begin		e := pop(inp^);		if ((e.elemType = IntElement) and (e.intValue = 0)) or ((e.elemType = FloatElement) and (e.floatValue = 0.0)) then			pushInteger(outp^, 1)		else			pushInteger(outp^, 0);	end;	procedure swap (inp, outp: PStack);		var			a, b: StackElement;	begin		a := pop(inp^);		b := pop(inp^);		push(outp^, a);		push(outp^, b);	end;	procedure dup (inp, outp: PStack);		var			e: StackElement;	begin		e := peek(inp^);		push(outp^, e);	end;	procedure rm (inp, outp: PStack);		var			dummy: StackElement;	begin		dummy := pop(inp^);	end;	procedure mv (inp, outp: PStack);		var			e: StackElement;	begin		e := pop(inp^);		push(outp^, e);	end;	procedure multipop (inp, outp: PStack);		var			e: StackElement;			count, i: longint;	begin		e := pop(inp^);		elemMustBe(e, IntElement, '\multipop expects a number but didn''t get one.');		count := e.intValue;		for i := 1 to count do			begin				e := pop(inp^);				push(outp^, e);			end;	end;	procedure plus (inp, outp: PStack);		var			fst, sec: StackElement;			fs, ss: string;			ff, sf: double;	begin		sec := pop(inp^);		fst := pop(inp^);		if (sec.elemType = StringElement) or (fst.elemType = StringElement) then			begin				fs := elemToString(fst);				ss := elemToString(sec);				pushString(outp^, concat(fs, ss));			end		else if (sec.elemType = FloatElement) or (fst.elemType = FloatElement) then			begin				ff := elemToFloat(fst);				sf := elemToFloat(sec);				pushFloat(outp^, ff + sf);			end		else			begin				pushInteger(outp^, fst.intValue + sec.intValue);			end;	end;{ \minus and friends }	function sub_si (s: string; i: longint): string;	begin		sub_si := copy(s, 1, length(s) - i);	end;	function sub_ss (haystack, needle: string): string;		var			buf: string;			len, i: byte;	begin		len := 0;		buf := '';		for i := 1 to length(haystack) do			if pos(haystack[i], needle) = 0 then				begin					len := len + 1;					buf[len] := haystack[i];				end;		buf[0] := chr(len);		sub_ss := buf;	end;	procedure minus (inp, outp: PStack);		var			fst, sec: StackElement;			ff, sf: double;			fi, si: longint;	begin		sec := pop(inp^);		fst := pop(inp^);		if (sec.elemType = IntElement) and (fst.elemType = IntElement) then			begin				pushInteger(outp^, fst.intValue - sec.intValue);			end		else if (sec.elemType = StringElement) and (fst.elemType = IntElement) then			begin				pushString(outp^, sub_si(sec.stringValue, fst.intValue));			end		else if (sec.elemType = IntElement) and (fst.elemType = StringElement) then			begin				pushString(outp^, sub_si(fst.stringValue, sec.intValue));			end		else if (sec.elemType = StringElement) and (fst.elemType = FloatElement) then			begin				fi := elemToInt(fst);				pushString(outp^, sub_si(sec.stringValue, fi));			end		else if (sec.elemType = FloatElement) and (fst.elemType = StringElement) then			begin				si := elemToInt(sec);				pushString(outp^, sub_si(fst.stringValue, si));			end		else if (sec.elemType = StringElement) and (fst.elemType = StringElement) then			pushString(outp^, sub_ss(fst.stringValue, sec.stringValue))		else if (sec.elemType = FloatElement) or (fst.elemType = FloatElement) then			begin				ff := elemToFloat(fst);				sf := elemToFloat(sec);				pushFloat(outp^, ff - sf);			end	end;{ \* and friends }	function mul_sf (s: string; iter: double): string;		var			count: double;			buf: string;			chars: byte;	begin		buf := '';		count := iter;		while count >= 1 do			begin				count := count - 1;				buf := concat(buf, s);			end;		if count > (1 / length(s)) then			begin				chars := round(length(s) * count);				buf := concat(buf, copy(s, 1, chars));			end;		mul_sf := buf;	end;	function mul_ss (s, expand: string): string;		var			buf: string;			i: byte;	begin		if length(expand) = 0 then			begin				mul_ss := s;				exit(mul_ss);			end;		for i := 1 to length(s) do			if s[i] = expand[1] then				buf := concat(buf, expand)			else				buf := concat(buf, s[i]);		mul_ss := buf;	end;	procedure mul (inp, outp: PStack);		var			sec, fst: StackElement;			sf, ff: double;	begin		sec := pop(inp^);		fst := pop(inp^);		if (fst.elemType = IntElement) and (sec.elemType = IntElement) then			pushInteger(outp^, fst.intValue * sec.intValue)		else if (fst.elemType = StringElement) and (sec.elemType = FloatElement) then			pushString(outp^, mul_sf(fst.stringValue, sec.floatValue))		else if (fst.elemType = StringElement) and (sec.elemType = IntElement) then			begin				sf := elemToFloat(sec);				pushString(outp^, mul_sf(fst.stringValue, sf));			end		else if (fst.elemType = FloatElement) and (sec.elemType = StringElement) then			pushString(outp^, mul_sf(sec.stringValue, fst.floatValue))		else if (fst.elemType = IntElement) and (sec.elemType = StringElement) then			begin				ff := elemToFloat(fst);				pushString(outp^, mul_sf(sec.stringValue, ff));			end		else if (fst.elemType = StringElement) and (sec.elemType = StringElement) then			pushString(outp^, mul_ss(fst.stringValue, sec.stringValue))		else if (fst.elemType = FloatElement) or (sec.elemType = FloatElement) then			begin				sf := elemToFloat(sec);				ff := elemToFloat(fst);				pushFloat(outp^, sf * ff);			end;	end;{ \div and friends }	function div_sf (s: string; divby: double): string;		var			l: longint;	begin		l := round(length(s) / divby);		div_sf := copy(s, 1, l);	end;	function div_ss (s, expand: string): string;		var			p: longint;			buf: string;	begin		buf := s;		p := pos(expand, buf);		while p <> 0 do			begin				delete(buf, p + 1, length(expand) - 1);				p := pos(expand, buf);			end;		div_ss := buf;	end;	procedure div_ (inp, outp: PStack);		var			sec, fst: StackElement;			sf, ff: double;	begin		sec := pop(inp^);		fst := pop(inp^);		if (fst.elemType = IntElement) and (sec.elemType = IntElement) then			pushInteger(outp^, fst.intValue div sec.intValue)		else if (fst.elemType = StringElement) and (sec.elemType = FloatElement) then			pushString(outp^, div_sf(fst.stringValue, sec.floatValue))		else if (fst.elemType = StringElement) and (sec.elemType = IntElement) then			begin				sf := elemToFloat(sec);				pushString(outp^, div_sf(fst.stringValue, sf));			end		else if (fst.elemType = FloatElement) and (sec.elemType = StringElement) then			pushString(outp^, div_sf(sec.stringValue, fst.floatValue))		else if (fst.elemType = IntElement) and (sec.elemType = StringElement) then			begin				ff := elemToFloat(fst);				pushString(outp^, div_sf(sec.stringValue, ff));			end		else if (fst.elemType = StringElement) and (sec.elemType = StringElement) then			pushString(outp^, div_ss(fst.stringValue, sec.stringValue))		else if (fst.elemType = FloatElement) or (sec.elemType = FloatElement) then			begin				sf := elemToFloat(sec);				ff := elemToFloat(fst);				pushFloat(outp^, sf / ff);			end;	end;	procedure n (inp, outp: PStack);		var			e: StackElement;			s: string;	begin		e := pop(inp^);		s := elemToString(e);		s := concat(s, chr(13));		pushString(outp^, s);	end;	procedure _ (inp, outp: PStack);		var			e: StackElement;			s: string;	begin		e := pop(inp^);		s := elemToString(e);		s := concat(s, ' ');		pushString(outp^, s);	end;	procedure word (inp, outp: PStack);		var			e: StackElement;	begin		e := pop(inp^);		if e.elemType = StringElement then			pushInteger(outp^, 1)		else			pushInteger(outp^, 0);	end;	procedure number (inp, outp: PStack);		var			e: StackElement;	begin		e := pop(inp^);		if (e.elemType = IntElement) or (e.elemType = FloatElement) then			pushInteger(outp^, 1)		else			pushInteger(outp^, 0);	end;	procedure integerp (inp, outp: PStack);		var			e: StackElement;	begin		e := pop(inp^);		if e.elemType = IntElement then			pushInteger(outp^, 1)		else			pushInteger(outp^, 0);	end;	procedure floatp (inp, outp: PStack);		var			e: StackElement;	begin		e := pop(inp^);		if e.elemType = FloatElement then			pushInteger(outp^, 1)		else			pushInteger(outp^, 0);	end;{ Equality over stack elements }	function elemsEQ (a, b: StackElement): Boolean;		var			af, bf: double;	begin		if (a.elemType = StringElement) and (b.elemType = StringElement) then			elemsEQ := a.stringValue = b.stringValue		else if (a.elemType = StringElement) and (b.elemType <> StringElement) then			elemsEQ := false		else if (a.elemType <> StringElement) and (b.elemType = StringElement) then			elemsEQ := false		else if (a.elemType = FloatElement) or (b.elemType = FloatElement) then			begin				af := elemToFloat(a);				bf := elemToFloat(b);				elemsEQ := af = bf;			end		else			elemsEQ := a.intValue = b.intValue;	end;	procedure eq (inp, outp: PStack);		var			a, b: StackElement;	begin		a := pop(inp^);		b := pop(inp^);		if elemsEQ(a, b) then			pushInteger(outp^, 1)		else			pushInteger(outp^, 0);	end;	procedure die_ (inp, outp: PStack);	begin		die;	end;{ trace0 and trace1 turn on and off tracing }	procedure trace1 (inp, outp: PStack);	begin		traceOn;	end;	procedure trace0 (inp, outp: PStack);	begin		traceOff;	end;{ This is where the fun starts }{ To break the circular dependency between stdlib and interp (so that \while can execute a context) }{ We store a procPtr to goCtx here }	var		goCtxPtr: ProcPtr;	procedure setStdlibGoCtx (p: ProcPtr);	begin		goCtxPtr := p;	end;{ This is Black Magic.  See callVerbProc in verbcall.p to see what it does. }	procedure callGoCtx_ (ctx: PCtx; addr: ProcPtr);	inline		$205F, { movea.l (a7)+, a0 }		$4E90; { JSR (a0) }	procedure callGoCtx (ctx: PCtx);	begin		callGoCtx_(ctx, goCtxPtr);	end;{ initStdLib adds the standard library to the verbcall table }	procedure initStdLib;	begin		addVerbProc('trace=0', @trace0);		addVerbProc('trace=1', @trace1);		addVerbProc('out', @out_);		addVerbProc('in', @in_);		addVerbProc('exec', @exec);		addVerbProc('verb', @verb_);		addVerbProc('if', @if_);		addVerbProc('while', @while_);		addVerbProc('not', @not_);		addVerbProc('swap', @swap);		addVerbProc('dup', @dup);		addVerbProc('rm', @rm);		addVerbProc('mv', @mv);		addVerbProc('multipop', @multipop);		addVerbProc('+', @plus);		addVerbProc('-', @minus);		addVerbProc('*', @mul);		addVerbProc('div', @div_);		addVerbProc('n', @n);		addVerbProc('_', @_);		addVerbProc('string?', @word);		addVerbProc('number?', @number);		addVerbProc('integer?', @integerp);		addVerbProc('float?', @floatp);		addVerbProc('eq?', @eq);		addVerbProc('die', @die_);	end;end.