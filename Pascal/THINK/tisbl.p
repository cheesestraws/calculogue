program tisbl;	uses		Types, Trace, Die, stack, verbcall, stdlib, Tokens, tokeniser, Ctx, interp, tests;	const{ Change this to run tests at the start of the application }		testing = false;	procedure loadFile;		const			buf_size = 4096;		type			Cbuf = packed array[1..buf_size] of char;		{ the 'packed' keyword stops the 'char's being aligned on word boundaries for speed! }		{ otherwise, you end up with every /other/ character of the file in the array. oops. }		{ not that it took me far too long to work this out, or anything... }			PBuf = ^cbuf;		var			filetypes: SFTypeList;			repl: StandardFileReply;			err: OSerr;			fileref: integer;			buf: CBuf;			s: Stack;			count: longint;			srclen: longint;			i: longint;			context: PCtx;			poppedItem: StackElement;	begin		fileTypes[0] := 'TEXT';		StandardGetFile(nil, 1, @fileTypes, repl);		if repl.sfGood then			begin		{ User did not cancel standard file dialog }				err := FSpOpenDF(repl.sfFile, fsRdPerm, fileref);				if err = 0 then					begin						err := GetEOF(fileref, srclen);			{ Create a stack to hold our soon-to-be-execution-stack }						s := newStack;						setToksStack(@s);						repeat							count := buf_size;							err := FSRead(fileref, count, @buf);{ Now, in theory, 'count' gets the length of the actual read if the buffer is bigger than the remaining data. }{ In practice, or at least in my practice, it seems not to.  Therefore, we'll fudge it.  srclen tracks the remaining}{ bytes in the file; if there's more than our buffer size, then the number of bytes read must have filled the buffer,}{ otherwise if there's less then that number of bytes must have been read! }							if srclen >= count then								srclen := srclen - count							else								count := srclen;							if (count > 0) then								for i := 1 to count do									toksReadChar(buf[i]);						until err <> 0;						err := FSClose(fileref);			{ force some pretend whitespace at the end of the file }						toksReadChar(' ');			{ Now we have our tokens on stack s.   We need to put them into our context's execution stack }						context := curContext;						while (s.top > 0) do							begin								poppedItem := pop(s);								push(context^.exec, poppedItem);							end;						freeStack(s);					end				else					begin						writeln('[FILE ERROR] Could not open file.');					end;			end;	end;begin{ initialise our nasty state stuff.  Ctx contains the contexts for each subprogram, toks is the tokeniser }	initTrace;	initCtx;	initToks;	initVerbCalls; { must be BEFORE initStdLib }	initInterp;	initStdLib;	if testing then		begin			traceOn;			runTests;		end;	startContext(nil, nil);	loadFile;	go;	endContext;	die;end.