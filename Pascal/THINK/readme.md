TISBL for THINK Pascal======================This is a TISBL interpreter written in non-object-oriented procedural Pascal for the Macintosh System 7.  The dialect in use is THINK's, which is very similar to other Pascal dialects in use on the Mac at this period - possessing units for modularisation and some degree of implementation hiding, and enough extra goodies to make the use of the Macintosh Toolbox feasible.  This version barely uses the toolbox; to make comparisons clearer across platforms it uses the standard Pascal read/write mechanism for textual I/O.  The toolbox calls are restricted to memory management (see Things to note below) and the file reading code in tisbl.p. In the same way, everything is implemented as fixed-size arrays to make the code easier to read.The dialect of Pascal that THINK uses did in fact have object-oriented features; this interpreter doesn't use them.System requirements-------------------This is 68k code.  It'll work on anything System 7+.  Probably including Classic under OS X, but I've not tried it!It works fine under Basilisk II.To get this to run------------------The binary application is in macstuff.sit.  Unstuff the archive, run the application and choose a TISBL source file.  To build it-----------You need:* A classic mac!  Or Basilisk II/SheepShaver/MiniMac with System 7.* Think Pascal 4.5 with Ingemar's UPI: see www.think-pascal.org, though the software seems to have vanished from there* This folderUn-stuff macstuff.sit into the current folder.  You'll get tisbl.&pi; and tisbl.rsrc.  This archive contains the files which need their resource forks intact.Open tisbl.&pi; in THINK Pascal and tell it to run!  You may need to increase the amount of memory available to the application in Run -> Run Options and to increase the amount of memory available to THINK Pascal itself (quit it and change its memory allocation in its Get Info window).Things to note--------------One: This dialect of Pascal has the slightly odd feature that while there is a way to take the address of a procedure, there is no way to then actually call that pointer.  I assume this is so that Pascal programs can supply callbacks to Toolbox routines that need them.  Procedure pointers are pretty useful: fortunately, using a bit of the ol' inline, it's possible to call them (see Rich Siegel's post at http://macgui.com/usenet/?group=23&start=6712&id=11944).  This trick is used in two places.  Firstly, the standard library, instead of consisting of an enormous if-then-else statement, consists of an array of records that map verb names to ProcPtrs; then when a verb name is encountered, it calls that ProcPtr.  Secondly, it's used to break the circular dependency between the interpreter (interp.p) and the standard library (stdlib.p).  The interpreter needs to call the standard library, to call its verbs; the standard library needs to call the interpreter, to do things like the bodies of while loops.  Since the standard library doesn't actually need to know anything about the interpreter other than its procedure prototype, it just has a procedure pointer.  When the interpreter initialises, it updates the stdlib's procedure pointer with the address of its own "go".Two: Leading on from this, there's no initialisers, anywhere.  This version of Pascal doesn't have them; either initial values on variables, or "initialization" sections in units.  The practical upshot of this is that if you have a variable defined in a unit, who knows what is going to be in it when the program starts.  This is why each of the units that has any kind of mutable state has an init procedure in it, which is called in tisbl.p at the start.Three: NewHandle.  Where there is memory allocated (for example, in stack.p), NewHandle is used.  This is a classic Macintosh idiom.  A handle is a pointer to a pointer.  The handle itself points into a master table, which acts as a table of contents for the heap.  This is so that the heap can be reorganised without breaking the application if, for example, it needs to be defragmented (see Inside Macintosh for details).  It's possible to lock a handle to prevent it being moved around - for example, this is used (possibly unnecessarily) in FloatToStr.p to make sure that the internationalisation table isn't moving while the application has a pointer to a part of it.  One should never save the pointer that a handle is pointing to unless it is locked!Four: THINK Pascal has only 32k of memory available for variables at each level, due to the vagaries of the 68000 architecture and it not having a workaround for these vagaries.  This accounts for the use of NewHandle() in stack.p.Five: Pascal can do pass-by-reference using 'var' parameters; the interpreter mixes this idiom with passing around pointers in different parts.  This is a semantic choice on my part; in general, when a TISBL stack name is resolved to a real stack I pass around a PStack to maintain the idea that what I'm throwing around is an opaque stack 'name', rather than a stack itself; when I'm throwing acting on an actual stack rather than a stack name, I use var.  There's little difference in the behaviour between var parameters and pointers in this case; it'd be entirely possible to rewrite the stdlib to take var parameters instead of PStacks.Things to poke--------------* Changing the 'tests' constant at the top of tisbl.p to 'true' will run some unit-type tests before the interpreter prompts for a source file.  The tests are in tests.p.* There are a load of _SIZE constants all over the place which change things like maximum depths of stacks and the size of the allowed standard library.  You can change these to run bigger programs (if you're insane and actually /want/ to write big TISBL programs).  Bear in mind, however, the above notes about memory size being limited to 32k for variables.  Rewriting the whole lot to use handles is left as an exercise for the reader!