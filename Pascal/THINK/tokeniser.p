unit Tokeniser;interface	uses		Stack;	procedure initToks;	procedure toksReadChar (c: char);	procedure toksReadString (s: string);	procedure toksMagic (s: string);	procedure setToksStack (s: PStack);implementation{ The tokeniser is in one of thre states, S (reading spaces), CM (comment) and T (reading tokens).  On transition }{ T->S, it calles toksMagic with the token then clears out the buffer.  % transitions S -> C; newline transitions C->S }	type		StateType = (S, T, CM);	var		buffer: string;		state: StateType;		st: PStack;	procedure initToks;	begin		buffer := '';		state := S;		st := nil;	end;	procedure setToksStack (s: PStack);	begin		st := s;	end;	function isSpaceChar (c: char): boolean;	begin		isSpaceChar := ord(c) <= 32;	end;	function isNewline (c: char): boolean;	begin		isNewline := (c = chr(10)) or (c = chr(13));	end;	function isComment (c: char): boolean;	begin		isComment := (c = '%');	end;{ traditional pascal strings are an array of chars where the length is in the first char. This converts a char to a }{ one-character string. }	function charToString (c: char): string;		var			s: string;	begin		s[0] := chr(1);		s[1] := c;		charToString := s;	end;	procedure toksReadChar (c: char);	begin		if (state = S) then			begin		{ In the whitespace state.  if we're reading any more whitespace, ignore it.   Otherwise add the char to }		{ the buffer and move to state T unless it's a %, in which case move to CM. }				if isComment(c) then					state := CM				else if not isSpaceChar(c) then					begin						buffer := concat(buffer, charToString(c));						state := T;					end;			end		else if (state = CM) then			begin				if isNewLine(c) then					state := S;			end		else			begin		{ In the text state.  If this is a text char, then add it to the buffer.  Otherwise, push the buffer out to the}		{ toksMagic, clear it, and return to S state. }				if not isSpaceChar(c) then					begin						buffer := concat(buffer, charToString(c));					end				else					begin						toksMagic(buffer);						buffer := '';						state := S;					end;			end;	end;	procedure toksReadString (s: string);		var			i: integer;	begin		for i := 1 to length(s) do			toksReadChar(s[i]);		toksReadChar(' ');	end;	procedure toksMagic (s: string);	begin		if st <> nil then			pushString(st^, s);	end;end.