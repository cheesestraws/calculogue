unit verbcall;interface	uses		Die, Stack, ctx, verbtable;	const		STDLIB_SIZE = 64; { The number of *native* verbs that can exist. }{ So, this is the unit that does the magic to turn verbs into procedure calls. }	type		VerbProc = ProcPtr;	procedure verb (v: string; inp, outp: PStack);	procedure addVerbProc (v: string; proc: VerbProc);	procedure addTISBLVerb (v: string; exec: Stack);	procedure initVerbCalls;implementation	type{ VerbProcs is the table for verbs which are implemented as Pascal procedures. }		VerbProcEntry = record				name: string;				code: ProcPtr;			end;		VerbProcs = record				top: 0..STDLIB_SIZE;				entries: array[1..STDLIB_SIZE] of VerbProcEntry;			end;	var		vs: VerbProcs;	procedure initVerbCalls;	begin		initVerbTable;		vs.top := 0;		vt^^.top := 0;	end;{ Oddly, although THINK Pascal provides the @ operator for procedures, it provides no way to call }{ procedures which have been referenced like that. }{ This procedure, given by Rich Seigel on usenet, calls a ProcPtr. }	procedure callVerbProc (inp, outp: PStack; addr: ProcPtr);	inline		$205F, { movea.l (a7)+, a0 }		$4E90; { JSR (a0) }{ The main entry point for the std library }	procedure verb (v: string; inp, outp: PStack);		var			i: integer;	begin{ Is there a TISBL verb? }		for i := 1 to vt^^.top do			if vt^^.entries[i].name = v then				begin					startContextAndExec(vt^^.entries[i].exec, inp, outp);					exit(verb);				end;{ Iterate through the stdlib trying to find the verb proc }		for i := 1 to vs.top do			if vs.entries[i].name = v then				begin					callVerbProc(inp, outp, vs.entries[i].code);					exit(verb);				end;{ Otherwise, we've got nothing. }		writeln('[VERBCALL] You called the verb \', v, ' but there is no such verb defined!');		die;	end;	procedure addVerbProc (v: string; proc: VerbProc);		var			p: VerbProcEntry;	begin		p.name := v;		p.code := proc;		if vs.top >= STDLIB_SIZE then			begin				writeln('[VERBCALL] Standard library is full!  Can''t add verb ', v);				die;			end;		vs.top := vs.top + 1;		vs.entries[vs.top] := p;	end;	procedure addTISBLVerb (v: string; exec: Stack);		var			s: Stack;			i: integer;	begin	{ The caller is responsible for freeing the original stack }	{ so we clone it }		s := cloneStack(exec);	{ Does the verb already exist? }		for i := 1 to vt^^.top do			if vt^^.entries[i].name = v then				begin		{Yes it does, so replace it and leave the procedure }					freeStack(vt^^.entries[i].exec);					vt^^.entries[i].exec := s;					exit(addTISBLVerb);				end;	{ If we get here, the verb does not exist }		if vt^^.top >= VT_SIZE then			begin				writeln('[VERBCALL] Too many verbs defined.');				die;			end;		vt^^.top := vt^^.top + 1;		vt^^.entries[vt^^.top].name := v;		vt^^.entries[vt^^.top].exec := s;	end;end.