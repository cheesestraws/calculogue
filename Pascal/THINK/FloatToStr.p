unit FloatToStr;{ }{ This unit contains a generic FloatToStr and StrToFloat pair of routines which wrap}{ StringToExtended and ExtendedToString in such a way that they're useful for TISBL. }{ The two lower-level pair of routines are ridiculously expressive/powerful, but I }{ hardly need that kind of tweakability here.  So I'm going to enforce some roughly sane }{ defaults and hope for the best. }{ }{ The name is a misnomer.  This deals with doubles, not floats. }{ }interface	uses		Types, fp, Script, Die;{ MaybeDouble can either contain a double or not a double! }	type		MaybeDouble = record				case maybe : boolean of					true: (							d: double;					)			end;	function DoubleToStr (f: double): string;	function StrToDouble (s: string): MaybeDouble;	function StrToDoubleOrDie (s: string): double;implementation	type		bytes4 = longint; { A longint is 4 bytes. This is NOT PORTABLE! }		PNumberParts = ^NumberParts;	const		formatString = '#########.#########;-#########.#########;0.0';{ THINK Pascal does't do pointer arithmetic, so we have to cast to a 4-byte int and back! }{ Which is a bit alarming.  This function hides this nastiness. }	function addToPtr (p: Ptr; offset: longint): Ptr;	begin		addToPtr := Ptr(bytes4(p) + offset);	end;	function DoubleToStr (f: double): string;		var			itHdl: Handle;			offset, length: longint;			numparts: PNumberParts;			formatRec: NumFormatString;			fmt: str255;			status: FormatStatus;			x: extended;			stringbuf: str255;	begin		fmt := formatstring;{ We need to get our number parts table, which controls how numbers are formatted for the }{ current locale }		GetIntlResourceTable(smCurrentScript, smNumberPartsTable, itHdl, offset, length);		HLock(itHdl);  	{ In theory nothing below moves memory, but let's make it robust in case }						{ see note in Stack.p about handles and lock and unlock. }		numparts := PNumberParts(addToPtr(itHdl^, offset));		status := StringToFormatRec(fmt, numparts^, formatRec);{ At this point, formatRec contains the necessary binary magic to format the string }{ Convert the longdouble to extended format }		x := f;		status := ExtendedToString(x, formatRec, numparts^, stringbuf);		HUnlock(itHdl);		if status = NoErr then			DoubleToStr := stringbuf		else			begin				writeln('[FloatToStr] Something'' s gone horribly wrong . Sorry !');				die;			end;	end;	function StrToDouble (s: string): MaybeDouble;		var			itHdl: Handle;			offset, length: longint;			numparts: PNumberParts;			formatRec: NumFormatString;			fmt: str255;			param: str255;			status: FormatStatus;			x: extended;			ret: MaybeDouble;	begin{See above for notes}		fmt := formatstring;		GetIntlResourceTable(smCurrentScript, smNumberPartsTable, itHdl, offset, length);		HLock(itHdl);  	{ In theory nothing below moves memory, but let's make it robust in case }						{ see note in Stack.p about handles and lock and unlock. }		numparts := PNumberParts(addToPtr(itHdl^, offset));		status := StringToFormatRec(fmt, numparts^, formatRec);		param := s;		status := StringToExtended(param, formatRec, numparts^, x);		HUnlock(itHdl);		if status = noErr then			begin				ret.maybe := true;				ret.d := x;			end		else			begin				ret.maybe := false;			end;		StrToDouble := ret;	end;	function StrToDoubleOrDie (s: string): double;		var			m: MaybeDouble;	begin		m := StrToDouble(s);		if not m.maybe then			begin		{It's not a number!}				write('[TOKS] ');				write(s);				writeln(' is not a number.');				die;			end;		StrToDoubleOrDie := m.d;	end;end.