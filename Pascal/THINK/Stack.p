unit stack;interface	uses		Trace, Die, FloatToStr;{ Stacks in this version are based on arrays, because I'm lazy. }	const		STACK_DEPTH = 512;	type		StackElementType = (StringElement, IntElement, FloatElement);		StackElement = record				case elemType : StackElementType of					StringElement: (							stringValue: string					);					IntElement: (							intValue: longint;					);					FloatElement: ({This was originally a float, hence the name}							floatValue: double;					);			end;{ We need to allocate the stack data on the heap because otherwise our variable is too big. }{ THINK Pascal has a small size limit on variables because of a technicality in 68000 machine }{ code... }		StackData = packed array[1..STACK_DEPTH] of StackElement;		PStackData = ^StackData;{ Note the use of handles here.  Handles are a regular feature of classic MacOS programming.  A handle}{ is a pointer to a pointer; the pointer it points to points to the data block.  This is so that MacOS can compact}{ the heap and move memory about without mucking around with things that have allocated data on the heap.}{ One should not, therefore, hang onto pointers to things on the heap unless you've allocated them with }{ NewPtr or locked the handle to prevent it moving. }		HStackData = ^PStackData;		Stack = record				valid: boolean; { has the stack been allocated?}				top: 0..STACK_DEPTH;				data: HStackData;			end;		PStack = ^Stack;	function newStack: Stack;	function cloneStack (s: Stack): Stack;	procedure freeStack (s: Stack);	function pop (var s: Stack): StackElement;	procedure pushString (var s: Stack; str: string);	procedure pushFloat (var s: Stack; d: double);	procedure pushInteger (var s: Stack; l: longint);	function peek (var s: Stack): StackElement;	procedure push (var s: Stack; e: StackElement);	function elemToString (s: StackElement): string;	function elemToFloat (s: StackElement): double;	function elemToInt (s: StackElement): longint;	procedure traceStack (var s: Stack; l: string);	procedure elemMustBe (e: StackElement; t: StackElementType; msg: string);implementation{ --- Assertions --- }	procedure StackFail (s: string);	begin		write('[STACK ERROR] ');		writeln(s);		die;	end;	procedure StackMustBeValid (s: Stack);	begin		if not s.valid then			StackFail('Internal error: stack claims to be invalid.');	end;	procedure StackMustNotBeEmpty (s: Stack);	begin		if s.top = 0 then			StackFail('Unexpectedly empty stack.');	end;	procedure StackMustNotBeFull (s: Stack);	begin		if s.top = STACK_DEPTH then			StackFail('Unexpectedly full stack.');	end;{ --- Allocation etc. --- }	function newStack: Stack;		var			s: stack;			a: HStackData;	begin		s.top := 0;		s.valid := true;		s.data := nil;	{ NewHandle allocates a block on the heap and returns a handle to it }		a := HStackData(NewHandle(sizeof(StackData)));		if a = nil then			begin				writeln('[STACK] Out of memory while allocating stack.');				die;			end;		s.data := a;		newStack := s;	end;	function cloneStack (s: Stack): Stack;		var			s2: Stack;			h: Handle;			err: OSerr;	begin{ This is slightly peculiar.  Hand2Hand takes a /reference/ to a handle and then overwrites that reference }{ with the new handle that the data has been copied to.  So, let's take a copy of the original handle to avoid }{ clobbering the original stack. }		h := Handle(s.data);		err := HandToHand(h);		if err < 0 then			begin				writeln('[STACK ERROR] Could not clone stack, OSErr is ', err);				die;			end;		s2.top := s.top;		s2.valid := true;		s2.data := HStackData(h);		cloneStack := s2;	end;	procedure freeStack (s: Stack);	begin		DisposHandle(Handle(s.data));		s.top := 0;		s.valid := false;	end;	function pop (var s: Stack): StackElement;		var			e: StackElement;	begin		StackMustBeValid(s);		StackMustNotBeEmpty(s);		e := s.data^^[s.top];		s.top := s.top - 1;		pop := e;	end;	function peek (var s: Stack): StackElement;		var			e: StackElement;	begin		StackMustBeValid(s);		StackMustNotBeEmpty(s);		e := s.data^^[s.top];		peek := e;	end;	procedure pushString (var s: Stack; str: string);		var			e: StackElement;	begin		StackMustNotBeFull(s);		e.elemType := StringElement;		e.stringValue := str;	{ increment the top and poke the value in }		s.top := s.top + 1;		s.data^^[s.top] := e;	end;	procedure pushFloat (var s: Stack; d: double);		var			e: StackElement;	begin		StackMustNotBeFull(s);		e.elemType := FloatElement;		e.floatValue := d;	{ increment the top and poke the value in }		s.top := s.top + 1;		s.data^^[s.top] := e;	end;	procedure pushInteger (var s: Stack; l: longint);		var			e: StackElement;	begin		StackMustNotBeFull(s);		e.elemType := IntElement;		e.intValue := l;	{ increment the top and poke the value in }		s.top := s.top + 1;		s.data^^[s.top] := e;	end;	procedure push (var s: Stack; e: StackElement);	begin		s.top := s.top + 1;		s.data^^[s.top] := e;	end;	function elemToInt (s: StackElement): longint;	begin		case s.elemType of			StringElement: 				StringToNum(s.stringValue, elemToInt);			IntElement: 				elemToInt := s.intValue;			FloatElement: 				elemToInt := round(s.floatValue);		end;	end;	function elemToString (s: StackElement): string;		var			buf: str255;	begin		case s.elemType of			StringElement: 				elemToString := s.stringValue;			IntElement: 				begin					NumToString(s.intValue, buf);					elemToString := buf;				end;			FloatElement: 				elemToString := DoubleToStr(s.floatValue);		end;	end;	function elemToFloat (s: StackElement): double;	begin		case s.elemType of			StringElement: 				elemToFloat := StrToDoubleOrDie(s.stringValue);			IntElement: 				elemToFloat := s.intValue;			FloatElement: 				elemToFloat := s.floatValue;		end;	end;	function elemToStringForTrace (s: StackElement): string;		var			str: string;			buf: str255;	begin		case s.elemType of			StringElement: 				str := concat('string.', s.stringValue);			IntElement: 				begin					NumToString(s.intValue, buf);					str := concat('int.', buf);				end;			FloatElement: 				str := concat('dbl.', DoubleToStr(s.floatValue));		end;		elemToStringForTrace := str;	end;	procedure traceStack (var s: Stack; l: string);		var			i: integer;	begin		mtraceStart;		mtrace(l);		mtrace(': ');		if s.top > 0 then			for i := s.top downto 1 do				mtrace(elemToStringForTrace(s.data^^[i]));		mtraceEnd;	end;{ Useful assertions }	procedure elemMustBe (e: StackElement; t: StackElementType; msg: string);	begin		if e.elemType <> t then			begin				writeln('[TYPE ERROR] ', msg);				die;			end;	end;end.